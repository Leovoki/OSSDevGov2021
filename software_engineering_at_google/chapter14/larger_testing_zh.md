# 第十四章
## 更大的测试						
															约瑟夫·格雷夫斯撰写，汤姆·曼施莱克编辑

在前面的章节中，我们已经叙述谷歌建立了属于自己的测试文化，以及单元测试是如何成为开发人员工作流程的基本部分的。但是其他类型的测试呢?事实证明，谷歌确实使用了许多其他的比单元测试大的测试，这些测试组成了软件编程过程中重要部分，用来应对风险。为了确保它们是有价值的资产，而不是资源的消耗这成为了测试的新挑战。在这一章中，我们将讨论 “大型测试”，什么是 “大型测试”，以及保持它们有效的最佳实践。

## 什么是“更大的测试”？
  如前所述，谷歌对测试大小是有定义的。小型测试仅限于一个线程、一个进程和一台机器。大型测试没有这种的限制。但是谷歌对测试范围也有概念定义。单元测试必须比集成测试的范围小。而最大范围的测试(有时称为端到端或系统测试)通常涉及几个真正的依赖项和更少的测试替身。

大型测试包含许多小测试所没有的东西。它们不受相同的约束;因此，它们可以表现出以下特征:

•他们可能比较慢。我们的大型测试有一个默认15分钟或1小时的超时，但是我们也有运行几个小时甚至几天的测试。
•它们可能是非封装好的。大型测试可能与其他测试和流量共享资源。
•他们可能是不确定的。如果一个大型测试是非封装好的，它几乎是不可能保证决定论的:也就是说其他测试或用户状态可能会干扰它。

那么为什么要进行更大的测试呢?回想一下你怎么敲代码的。你如何保证你写的程序可以正常运行?您可能正在写和运行单元测试，但你是否发现是你自己在尝试运行这些二进制软件呢?当你与他人分享这些代码时，他们如何测试它?让他们自己尝试运行单元测试?

另外，你怎么知道在版本迭代过程种你的代码还能正常运行?假设你有一个网站用到谷歌的地图API，同时这个API有待更新。你可能并不知道测试能否和新版本兼容所以你会尝试看一下运行是否正常。

## 保真度

使用较大测试的主要原因是为了解决保真度问题。保真度是一种属性，通过它，测试可以反映在测试过程种系统的真实情况（SUT）。

设想保真度是一种根据环境的方法。正如图14-1所示，单元测试将一个测试和一小部分代码捆绑在一起作为一个可运行的单元，这确保了代码经过了测试，但不同于生产代码的运行方式。自然，生产本身就是测试中保真度最高的环境。还有一系列临时选择权。大型测试的关键是找到合适的匹配，因为提高保真度也伴随着成本的增加和(在生产环境下)失败风险的增加。

![图14-1 保真度增加的规模](https://img-blog.csdnimg.cn/20210421160629827.png)
图14-1保真度增加的规模

还可以根据测试内容对现实的逼真度来衡量测试。 许多手工的，很大的测试都被工程师忽略，是因为这些测试都看起来不真实。 从生产中复制的测试数据更加接近于现实，但是最大的挑战是如何在之启动新代码之前创建真实的测试流量。 这在人工智能（AI）中也是个问题，因此，“种子”数据经常遭受内在偏见。并且因为大部分用来单元测试的数据都是手动生成的，这些数据只包含了例子的一小部分，而且往往带别了创造数据这个人的想法。没有被测试数据覆盖到的真实场景表明了一次测试的保真度差距。

## 单元测试中的常见差距
如果较小的测试失败，则可能需要较大的测试。 遵循的小节低表示某些特定区域中的单元测试无法提供良好的风险评估位置覆盖率。紧跟其后的分段只展现了一些特定的地方，因而单元测试不能很好的提供风险缓冲覆盖。

### 不可靠的双重测试
单个单元测试通常涵盖一个类或模块。双重测试(如第13章提到的)经常被用来消除影响大的的或难以测试的依赖性。但是当这些依赖被替换时，替换物和被替换物之间可能会有分歧。

Google几乎所有的单元测试都是由编写该测试的同一位工程师编写的。当那些单元测试需要双倍时，而且是模拟的话，是由工程师来给模拟下定义和指定行为。但这位工程师通常不会写模拟，因为他们可能传达错误的信息。被测的单元与给定同伴之间的关系是一种行为契约，如果工程师错误地理解了实际行为，那么对契约的理解是无效的。

而且模拟显得陈旧。如果基于模拟的单元测试对于实际运用的作者而言不可见的话，或者实际应用改变的话， 没有任何提示可以显示该测试需要和变化同步。

请注意，正如第13章中提到的，如果团队为他们自己提供假冒的服务，这种担忧就会大大减轻。

### 配置问题
单元测试涵盖给定的二进制代码。但是，就执行方式而言，二进制文件通常不是完全自给自足的。二进制文件通常需要一定的部署配置或启动脚本。此外，真正的终端用户服务产品都有自己的配置文件或配置数据库。

如果这些文件存在问题，或者这些存储定义的状态与涉及的二进制文件之间存在兼容性问题，那么这些问题可能会导致重大的用户问题。单靠单元测试无法验证这种兼容性。另外说一句，这反而是一个让你保证配置和代码都处于版本控制中的不错理由。因为随后的配置变化可以被识别来作为bug（漏洞）的来源而不是引入外部的随机碎片并且这可以运用于大测试中。

*[单靠单元测试无法验证这种兼容性。]:   请参阅第483页和第25章的“持续交付”了解更多信息。


在谷歌，配置更改是我们主要停机的首要原因。这是我们表现不佳的一个领域，并导致了一些最令人尴尬的bug。例如，在2013年有一次谷歌的全球宕机，原因是一个糟糕的网络配置推送因为它未经测试。配置往往是用配置语言编写的，而不是生产环境的代码编写的。与二进制文件相比，它们的产品推出周期通常更快，而且可能更难被测试。所有这些都导致了失败的可能性。但至少在这种情况下(以及其他情况)，配置被包括进版本控制，然后我们可以很快的找到罪魁祸首并减轻问题的发生。

### 负载情况下的问题
在谷歌，单元测试的目的是要小而快，因为它们需要适应我们的标准测试的基础结构，而且还可以作为无摩擦开发人员工作流的一部分而多次运行。但是性能、负载和压力测试通常需要向给定的二进制文件发送大量的通信。这么大的量在普通的单元测试模型中很难进行。而且我们的访问量非常大，通常每秒有数千或数百万次查询(比如广告和实时竞价)！

### 未预料到的行为、输入和副作用
单元测试是受限于工程师的想象力的。也就是说，它们只能测试预期的行为和输入。然而，用户在产品中发现的问题大多是意料之外的(否则，它们不太可能作为问题出现在最终用户面前)。这一事实表明，需要不同的测试技术来测试未预料到的行为。
Hyrum法则在这里是一个重要的考虑因素:即使我们可以100%地测试一致性基于严格的具体的协议，有效的用户合同适用于所有可见的行为，而不仅仅是一个规定的合同。单元测试不太可能单独测试公共API中没有指定的所有可见行为。

### 突发行为与“真空效应”
单元测试被限制在它们所覆盖的范围内(特别是在广泛使用双重测试的情况下)，因此，如果行为在这个范围之外的区域发生了变化，则无法检测到它。而且，由于单元测试被设计成快速和可靠的，它们有意地消除了实际依赖关系、网络和数据的混乱。单元测试就像理论物理学中的问题:放在真空中，巧妙地隐藏在现实世界的混乱之中，这对速度和可靠性很有好处，但却忽略了某些缺陷。

## 为什么不进行更大的测试呢？
在前面的章节中，我们讨论了开发人员友好测试的许多属性。
特别地，它需要如下：

可靠的
它一定不能剥落，并且必须提供有用的通过/失败信号。

快速地:
它需要足够快以不打扰开发人员的工作流程。

可扩展:
Google需要能够有效地运行所有这些有用的受影响的测试，以进行预sub-麻省理工学院和提交后。好的单元测试具有所有这些特性。较大的测试通常会违反所有这些条件约束。例如，较大的测试通常比较脆弱，因为它们使用更多的红外线结构要比小型单元测试好。它们通常也慢得多，两者都需要设置以及跑步。而且由于资源和时间的原因，他们很难扩展要求，但通常还因为它们不是孤立的—这些测试可能会发生冲突彼此之间。

另外，较大的测试提出了另外两个挑战。首先，有一个挑战所有权。单元测试显然由拥有该测试的工程师（和团队）拥有单元。较大的测试跨多个单元，因此可以跨多个所有者。这提出了长期所有权挑战：谁负责维护测试当测试中断时，谁负责诊断问题？没有明确所有权，考验腐烂。

大型测试的第二个挑战是标准化（或缺乏标准化）之一。
与单元测试不同，大型测试的基础设施缺乏标准化编写，运行和调试它们的结构和过程。的方法大型测试是系统架构决定的产物，因此引入了var-要求的测试类型。例如，我们构建和运行A-B差异的方式Google Ads中的回归测试与此类测试的方式完全不同在搜索后端中构建并运行，这与云端硬盘有所不同。他们使用不同的功能强大的平台，不同的语言，不同的基础架构，不同的库，以及竞争性测试框架。

缺乏标准化会产生重大影响。 因为较大的测试有有许多种运行方式，在大规模更改中通常会跳过它们。 （看第22章。基础结构没有运行这些测试的标准方法，并且要求执行LSC的人员了解每个测试的本地详细信息团队规模不大。 由于大型测试的实施因团队而异，实际测试这些团队之间的集成的测试需要统一的不兼容可行的基础架构。也因为缺少相应的标准化流程，我们不能教对Nooglers(新谷歌人)或更有经验的工程师采取单一的方法，这既使这种情况持续下去，也导致人们对此类测试的动机缺乏理解。

## 在谷歌更大的测试
当我们之前讨论谷歌的测试历史时(见第11章)，我们提到了谷歌网络服务 (GWS)是如何在2003年强制进行自动化测试的，以及这是如何成为一个分水岭的。然而，在此之前，我们实际上已经使用了自动化测试，但常见的做法是使用自动化的大型测试。例如，AdWords在2001年创建了一个端到端测试，以验证产品的实际情况。类似地，2002年，Search为它的索引代码编写了一个类似的“回归测试”，而AdSense(它甚至还没有公开发布)在AdWord上创建了它的变体。

其他“更大”的测试模式大约也存在于2002年。谷歌搜索前端严重依赖端到端测试场景的手动qa -手动版本。和Gmail获得了它的“本地演示”环境版本——一个脚本，用来在本地创建一个端到端Gmail环境，并生成一些测试用户和邮件数据，用于本地手动测试。

当C/J构建(我们的第一个持续构建框架)发布时，它并没有区分单元测试和其他测试，但是有两个关键的开发导致了分裂。
首先，谷歌专注于单元测试，因为我们希望鼓励测试金字塔，并确保绝大多数的书面测试都是单元测试。
第二，当TAP取代C/J Build作为我们正式的持续构建系统时，它只能对满足TAP合格性要求的测试这样做:可在单个更改下构建的密封测试，该更改可以在最大时间限制内运行在我们的构建/测试集群上。
虽然大多数单元测试满足这一要求，但大型测试大多不满足这一要求。
然而，这并没有阻止对其他类型的测试的需要，它们继续填补覆盖范围的空白。
C/J Build甚至为了处理这类测试而存在了好几年，直到更新的系统取代它。

### 更大的测试和更多的时间
在本书中，我们探讨了时间对软件工程师的影响因为谷歌开发的软件已经运行了20多年。是如何受时间维度影响较大的测试?我们知道某些活动会代码的预期寿命越长，对各种形式的测试就越有意义在所有级别上都有意义的活动，但是测试类型是适当的在代码的预期生命周期内。

正如我们之前指出的，单元测试开始对具有预期寿命数小时以上的软件是具有意义的。在分钟级别上，手动测试是非常普遍的。往往STU在本地测试。但本地的演示可能是生产，特别是一次性脚本、演示或实验。在较长的寿命期间，手工测试将继续存在，但SUT通常会出现分歧，因为生产实例通常是云托管的，而不是本地托管的。

其余的大型测试都为长期存在的软件提供了价值，但是随着时间的增加，主要的关注点变成了此类测试的可维护性。

顺便说一下，这种时间影响可能是开发“冰淇淋甜筒”测试反模式的原因之一，如第11章所述，以及这里的图14-2所表示的。
![图14-2](https://img-blog.csdnimg.cn/20210425103209828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjgyMzAxOQ==,size_16,color_FFFFFF,t_70)
图14-2

  
  当开发开始于手动测试时(当工程师认为代码只会持续几分钟)，这些手动测试就会累积起来，并主导整个测试组合。例如，它是相当典型的入侵一个脚本或应用程序，并通过运行它来测试它，然后继续添加功能，但继续通过手动运行它来测试它。这个原型最终会实现功能，并与他人共享，但实际上没有针对它的自动化测试。

糟糕的是，如果代码很难进行单元测试(因为它最初的实现方式)，那么唯一可以编写的自动化测试就是端到端测试，而我们在几天内就无意中创建了“遗留代码”。

在开发的头几天内通过构建单元测试向测试金字塔过渡，然后通过引入自动化集成测试和从手动的端到端测试转移到测试金字塔，这对于长期健康是至关重要的。我们成功得将单元测试作为一次请求提交了，但是覆盖单元测试和手动测试之间的差距对于长期健康运行是必要的。

### 谷歌规模的更大测试
在更大的软件规模中，似乎更大的测试更有必要也更合适，但即便如此，编写、运行、维护和调试这些测试的复杂性也会随着规模的增长而增加，甚至比单元测试更复杂。

微服务组成的一个系统或单独的服务器,公司的模式及互连附带应承担的看起来像一个图:让图中的节点数量是我们的n .每次一个新节点添加到这张图,有一个乘法效应的数量不同的执行路径。

图14-3描绘了一个想象中的SUT:这个系统由一个有用户的社交网络、一个社交图、一串帖子和一些广告组成。广告是由广告商创造的，并在社交流的背景下服务。这个SUT单独由两组用户、两个ui、三个数据库、一个索引管道和六个服务器组成。
图中枚举了14条边。测试所有的端到端可能性已经很困难了。想象一下，如果我们向这个组合中添加更多的服务、管道和数据库:照片和图像、机器学习照片分析等等?

![图14-3](https://img-blog.csdnimg.cn/20210425111945182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjgyMzAxOQ==,size_16,color_FFFFFF,t_70)图14-3 一个相当小的SUT的例子:一个带有广告的社交网络

以端到端方式进行测试的不同场景的速率可以呈指数级增长或组合增长，这取决于被测试系统的结构，而且这种增长不具有伸缩性。因此，随着系统的增长，我们必须找到可选择的更大的测试策略来保持可管理。

然而，由于为实现这一比例尺而作出的必要决定，这种检验的价值也有所增加。
这是保真度的影响:
当我们迈向大N层软件,如果服务双打低保真(1 -ε),错误的机会把它放在一起时指数n .再看看这个例子SUT,如果我们将用户服务器和广告服务器替换为双打和混双低保真(例如,10%准确),
出现bug的可能性为99%(1(0.1 0.1))。这还只是两个低保真度。

因此，以在此规模上工作良好但保持合理高保真度的方式实现更大的测试变得至关重要。

![图14-4](https://img-blog.csdnimg.cn/20210425112212624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjgyMzAxOQ==,size_16,color_FFFFFF,t_70)
图14-4 链式测试

## 更大测试的结构

尽管大型测试不受小型测试约束的约束，并且可以由任何东西组成，但大多数大型测试都表现出常见的模式。大型测试通常包含以下阶段的工作流:

•获得一个被测系统
•播种必要的试验数据
•使用被测系统执行操作
•验证行为